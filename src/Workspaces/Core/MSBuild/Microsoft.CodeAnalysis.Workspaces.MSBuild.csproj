<?xml version="1.0" encoding="utf-8"?>
<!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. See the LICENSE file in the project root for more information. -->
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>Library</OutputType>
    <RootNamespace>Microsoft.CodeAnalysis</RootNamespace>
    <TargetFrameworks>$(SourceBuildTargetFrameworks);net472</TargetFrameworks>
    <DefineConstants>$(DefineConstants);WORKSPACE_MSBUILD</DefineConstants>
    <!-- NuGet -->
    <IsPackable>true</IsPackable>
    <IncludeContentInPack>true</IncludeContentInPack>

    <!-- We are packing DLLs into the content directories of the NuGet package because that's what where the BuildHosts will go; NuGet warns we may not want that since they won't be referenced;
         that is exactly what we do want here. -->
    <NoWarn>$(NoWarn);NU5100</NoWarn>

    <PackageDescription>
      .NET Compiler Platform ("Roslyn") support for analyzing MSBuild projects and solutions. This should be used with at least one
      of the following packages to add the appropriate language support:
      - Microsoft.CodeAnalysis.CSharp.Workspaces
      - Microsoft.CodeAnalysis.VisualBasic.Workspaces
    </PackageDescription>
  </PropertyGroup>
  <ItemGroup>
    <PackageReference Include="Microsoft.Build" Version="$(RefOnlyMicrosoftBuildVersion)" />
    <PackageReference Include="Microsoft.Build.Framework" Version="$(RefOnlyMicrosoftBuildFrameworkVersion)" />
    <PackageReference Include="Microsoft.Build.Tasks.Core" Version="$(RefOnlyMicrosoftBuildTasksCoreVersion)" />
    <PackageReference Include="System.Text.Json" Version="$(SystemTextJsonVersion)" />
    <PackageReference Include="StreamJsonRpc" Version="$(StreamJsonRpcVersion)" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\..\..\Compilers\Core\Portable\Microsoft.CodeAnalysis.csproj" />
    <ProjectReference Include="..\MSBuild.BuildHost\Microsoft.CodeAnalysis.Workspaces.MSBuild.BuildHost.csproj" />
    <ProjectReference Include="..\Portable\Microsoft.CodeAnalysis.Workspaces.csproj" />
  </ItemGroup>
  <ItemGroup>
    <PublicAPI Include="PublicAPI.Shipped.txt" />
    <PublicAPI Include="PublicAPI.Unshipped.txt" />
  </ItemGroup>
  <ItemGroup>
    <InternalsVisibleTo Include="Microsoft.CodeAnalysis.LanguageServer" />
    <InternalsVisibleTo Include="Microsoft.CodeAnalysis.Workspaces.Test.Utilities" />
    <InternalsVisibleTo Include="Microsoft.CodeAnalysis.Workspaces.MSBuild.UnitTests" />
    <InternalsVisibleTo Include="DynamicProxyGenAssembly2" Key="$(MoqPublicKey)" LoadsWithinVisualStudio="false" />
  </ItemGroup>
  <ItemGroup>
    <EmbeddedResource Update="WorkspaceMSBuildResources.resx" GenerateSource="true" />
  </ItemGroup>
  <!--
    Include the BuildHost binaries into this package as well as a regular library. At the moment, we're including it in lib because we're internally using it as a library in-process for a few of our 
    RPC interfaces with our remote process.
    -->
  <PropertyGroup>
    <TargetsForTfmSpecificBuildOutput>$(TargetsForTfmSpecificBuildOutput);GetBuildHostBinaries</TargetsForTfmSpecificBuildOutput>
    <TargetsForTfmSpecificDebugSymbolsInPackage>$(TargetsForTfmSpecificBuildOutput);GetBuildHostDebugSymbols</TargetsForTfmSpecificDebugSymbolsInPackage>
  </PropertyGroup>
  <Target Name="GetBuildHostBinaries" DependsOnTargets="ResolveReferences">
      <MSBuild Projects="..\MSBuild.BuildHost\Microsoft.CodeAnalysis.Workspaces.MSBuild.BuildHost.csproj" Targets="_GetBuildOutputFilesWithTfm">
        <Output TaskParameter="TargetOutputs" ItemName="BuildOutputInPackage" />
      </MSBuild>
  </Target>
  <Target Name="GetBuildHostDebugSymbols">
    <MSBuild Projects="..\MSBuild.BuildHost\Microsoft.CodeAnalysis.Workspaces.MSBuild.BuildHost.csproj" Targets="_GetDebugSymbolsWithTfm">
      <Output TaskParameter="TargetOutputs" ItemName="_TargetPathsToSymbolsWithTfm" />
    </MSBuild>
  </Target>

  <!--
    Deploy a net472 and net6.0 version of the BuildHost process which will be used depending on the type of project. We will use the deployed version even if
    it matches the runtime type of the caller of MSBuildWorkspace since we still need the separate process for dependency isolation and in the case of the .NET Core
    side, ensuring we potential rollforward to a runtime that supports the SDK version.

    The NuGet packaging targets will package Content files, but the outer "pack" build assumes that the content files are just found in the project file directly and
    gives us no way to say we need to run a target to produce them. The BeforeTargets="_GetPackageFiles" forces it to run in that case; ideally there'd be a "pack content depends on"
    property that we could hook but we can't in this case.
  -->
  <Target Name="DeployNetFrameworkBuildHost" BeforeTargets="_GetPackageFiles;AssignTargetPaths" Condition="'$(DesignTimeBuild)' != 'true'">
    <ItemGroup>
      <_NetFrameworkBuildHostProjectReference Include="..\..\..\Workspaces\Core\MSBuild.BuildHost\Microsoft.CodeAnalysis.Workspaces.MSBuild.BuildHost.csproj">
        <TargetFramework>net472</TargetFramework>
      </_NetFrameworkBuildHostProjectReference>
      <_NetFrameworkBuildHostProjectReference Include="..\..\..\Workspaces\Core\MSBuild.BuildHost\Microsoft.CodeAnalysis.Workspaces.MSBuild.BuildHost.csproj">
        <TargetFramework>net6.0</TargetFramework>
      </_NetFrameworkBuildHostProjectReference>
    </ItemGroup>

    <!-- We include Build as a target we invoke to work around https://github.com/dotnet/msbuild/issues/5433  -->
    <MSBuild Projects="@(_NetFrameworkBuildHostProjectReference)"
             Targets="Build;BuiltProjectOutputGroup;ReferenceCopyLocalPathsOutputGroup"
             Properties="TargetFramework=%(_NetFrameworkBuildHostProjectReference.TargetFramework)">
      <Output TaskParameter="TargetOutputs" ItemName="NetFrameworkBuildHostAssets" />
    </MSBuild>

    <ItemGroup>
      <!-- We're setting both TargetPath and PackagePath here, the former when this is used in a regular build to deploy and the latter for
           when this called during pack. By putting the PackagePath in any/any, we only have to deploy this once rather than per TFM.
           Similarly, we set CopyToOutputDirectory for the regular build and PackageCopyToPutput for the packaging process. -->
      <Content Include="%(NetFrameworkBuildHostAssets.Identity)"
               Condition="'%(NetFrameworkBuildHostAssets.TargetPath)' != '' and '%(NetFrameworkBuildHostAssets.Extension)' != '.xml'"
               TargetPath="BuildHost-%(NetFrameworkBuildHostAssets.TargetFramework)\%(NetFrameworkBuildHostAssets.TargetPath)"
               PackagePath="contentFiles\any\any\BuildHost-%(NetFrameworkBuildHostAssets.TargetFramework)\%(NetFrameworkBuildHostAssets.TargetPath)"
               CopyToOutputDirectory="PreserveNewest"
               PackageCopyToOutput="true" />
    </ItemGroup>
  </Target>
</Project>